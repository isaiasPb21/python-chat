from threading import *   
from datetime import *
from tkinter import *
from tkinter import messagebox  
import socket
import time
import random

class Aplicacao ():
    def __init__(self, master=None):        
        self.fontePadrao = ("Verdana", "13")

        alfabeto = ['ª','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','â','ã','é','ç','õ','0','1','2','3','4','5','6','7','8','9',' ',',','.','+','-','*',':','/','\\','!','@','#','$','%','&','(',')']

        # ********************************************************************************************************************** FUNÇÕES
        def horario():
            horario = datetime.now()
            horario = horario.strftime('%H:%M %Y %S')
            return horario
        # ************************************************
        # ************************************************
        def calcAlea (fim=1000):                 
            aleatorio = random.randint(0,fim)
            return aleatorio

        def calcPrimo (num):                      
            acumulador = 0
            for n in range(1,num+1,1):
                aux = (num % n)
                if aux == 0:
                    acumulador += 1
                if (aux ==0) and (n != 1) and (n !=num):
                    return calcPrimo(num+1)
            if acumulador <= 2:
                return num
        
        numP = calcPrimo(calcAlea())     
        numQ = calcPrimo(calcAlea())

        feedN = ((numP-1) * (numQ-1))                   

        minha_chaveE = calcPrimo(calcAlea(feedN-200))
        minha_chaveN = (numP * numQ)

        chaves = (minha_chaveE, minha_chaveN)

        minha_chaveD = 0
        x=0
        while x < minha_chaveN:
            r = (x * minha_chaveE) % feedN
            if r == 1:
                minha_chaveD = x
                break
            x += 1

        print('P {} * Q {} * N {} * D {} * E {}'.format(numP, numQ, minha_chaveN, minha_chaveD, minha_chaveE))
        # ************************************************
        def enviarChaves(delay):
            try:
               nome = self.ed2.get()
               print('Entrou no enviarCh')  
               ip = '192.168.15.9'
               port = 2121
               add = (ip, port)   
               clientSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
               time.sleep(delay)  
               clientSocket.connect(add)   
               y = '#1-' + str(minha_chaveE) + "=" + str(minha_chaveN) + '+' + nome + '*'
               clientSocket.sendto(y.encode(), (ip, port))   
               print('Chaves que foi enviada' + y)
               clientSocket.close()
            except ConnectionRefusedError:
               print('ConnectionRefusedError : Não foi possivel enviar as chaves')
        

        # ************************************************
        # ************************************************
        def recebeMensagem ():
            host = '192.168.15.8'
            port = 2121
            add = (host, port)   
            serv_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            serv_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            serv_socket.bind(add)
            serv_socket.listen(10)
            enviarChaves(5)
            while True:
                 global outro_chaveE, outro_chaveN
                 con, cliente = serv_socket.accept()
                 recebe = con.recv(2024)
                 recebe = recebe.decode()  
                 print('Mensagem Recebida : ', recebe)   #
                 
                 if (recebe[0] == '#') and (recebe[1] == '1') and (recebe[2] == '-'):
                     print('Ow shit')
                     sliceKeyE = recebe.index('=')
                     outro_chaveE = recebe[3:sliceKeyE]
                      
                     sliceKeyN = recebe.index('+')
                     outro_chaveN = recebe[sliceKeyE+1:sliceKeyN]
                     print('Chaves Recebidas E {}, N {}'.format(outro_chaveE,outro_chaveN))

                     sliceName = recebe.index('*')
                     nomeOutro = recebe[sliceKeyN+1:sliceName]
                     print('Nome : ', nomeOutro)

                     self.lbNomeOutro["text"] = nomeOutro
                     
                 labelMessage2 = Label(self.frame, text=recebe, anchor=W, wraplength=200, bg="#f5f5f5", width=63)
                 labelMessage2.pack(fill="both", padx=5, pady=10, ipadx=5, ipady=10)   

        # ************************************************
        def avancar(event):
            
            time.sleep(5)
            print('Avancar')
            self.frameUm_nome["bg"] = "yellow"
            self.frameUm_nome.pack_forget()
            
            self.frameNome = Frame(master)                                                   # Frame Show his name
            self.frameNome.pack(side=TOP, fill="both")
            
            self.lbNomeOutro = Label(self.frameNome, text="Nome Outro")
            self.lbNomeOutro.pack(fill=X, pady=5)

            self.frameShowMessage = Frame(master, bg="yellow", relief=FLAT)             # Show Message
            self.frameShowMessage.pack(side=TOP, fill="both")

           # ************************************************
            def enviarMensagens(event):
                global outro_chaveE, outro_chaveN
                print('Enviando')                   
                ip = '192.168.15.9'
                port = 2121
                add = (ip, port)           
                clientSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                clientSocket.connect(add)

                # Chaves
                outro_chaveE = int(outro_chaveE)
                outro_chaveN = int(outro_chaveN)
                print('Area de envio : chave E {}, chave N : {}'.format(outro_chaveE,outro_chaveN))
                
                # Mensagem
                x = self.message.get().lower()
                print(x)         
                 # Pré Cifragem   
                preCodificadoEnvio = []      
                codificadoRsaEnvio = []
                codificadoRsaStringEnvio = []
       
                for i in x:
                   aux3 = alfabeto.index(i) * 10
                   preCodificadoEnvio.append(aux3)

                # Cifragem
                for i in preCodificadoEnvio:
                   aux4 = (i ** outro_chaveE) % outro_chaveN
                   codificadoRsaEnvio.append(aux4)

                for i in codificadoRsaEnvio:
                   aux5 = str(i)
                   codificadoRsaStringEnvio.append(aux5)
      
                codificadoRsaEnvio = '_'.join(codificadoRsaStringEnvio)    

                print("Enviando ... ")
                clientSocket.sendto(codificadoRsaEnvio.encode(), (ip, port))
                print("Enviado")
                self.message.delete(0, END)
                
                labelMessage = Label(self.frame, text=x, anchor=E, wraplength=200, bg="lightgray", width=63)
                labelMessage.pack(fill="both", padx=5, pady=10, ipadx=10, ipady=10)
                self.message.delete(0, END)
      
           # ************************************************            
            def myfunction(event):
                canvas.configure(scrollregion=canvas.bbox("all"),width=550,height=470, bg="#dcdcdc")
                
           # ************************************************
           
            self.myframe=Frame(master,relief=FLAT)
            self.myframe.pack()         
        
            canvas=Canvas(self.myframe,width=550,height=470, bg="#dcdcdc")
            self.frame=Frame(canvas, bg="#dcdcdc")
            myscrollbar=Scrollbar(self.myframe,orient="vertical",command=canvas.yview)
            canvas.configure(yscrollcommand=myscrollbar.set)

            myscrollbar.pack(side="right",fill="y")
            canvas.pack(side="left")
            canvas.create_window((0,0),window=self.frame,anchor=NW)
            self.frame.bind("<Configure>",myfunction)
    

            self.labelMessage = Label(self.frameShowMessage, text="Sessão de chat criptografado ponta a ponta", wraplength=250, bg="orange")
            self.labelMessage.pack(fill=X, padx=5, pady=10, ipadx=5, ipady=10)

            self.frameShowInput = Frame(master, bg="yellow")                         # Show Input 
            self.frameShowInput.pack(side=BOTTOM, fill="both")

            self.message = Entry(self.frameShowInput, borderwidth=0, insertbackground="lightgray", bg="orange")
            self.message.focus_set()
            self.message.bind("<Return>", enviarMensagens)
            self.message.pack(fill=X, padx=20, pady=10)

            funcao1 = Thread (target=recebeMensagem) 
            funcao1.start()
            
        # ************************************************
        # Nome
        self.frameUm_nome = Frame(master, bg="#ff71ff")                      # Frame M                                                                                                              
        self.frameUm_nome.pack(fill="both", pady=250)

        # Label + Entry
        self.lb1 = Label(self.frameUm_nome, text = "Open : "+ horario() + ' s', anchor=W, fg="#fff", bg="#ff71ff").pack(fill=X)
        self.lb2 = Label(self.frameUm_nome, text = "Nome : ", anchor=W, fg="#fff", bg="#ff71ff").pack(fill=X, padx=150)
        
        self.ed2 = Entry(self.frameUm_nome, width=30, borderwidth=0, insertbackground="lightgray", bg="#ff71ff", fg="#fff")
        self.ed2.focus_set()
        self.ed2.bind("<Return>", avancar)
        self.ed2.pack(pady=5)

root = Tk()
root.geometry("550x620+250+80")
root.configure(background="#fad2fa")
Aplicacao(root)
root.mainloop()  
