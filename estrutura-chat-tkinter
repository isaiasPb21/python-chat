from threading import *   
from datetime import *
from tkinter import *
from tkinter import messagebox  
import socket
import time
import random

class Aplicacao ():
    def __init__(self, master=None):        
        self.fontePadrao = ("Verdana", "13")

        alfabeto = ['ª','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','â','ã','é','ç','õ','0','1','2','3','4','5','6','7','8','9',' ',',','.','+','-','*',':','/','\\','!','@','#','$','%','&','(',')']


        # ********************************************************************************************************************** FUNÇÕES

        def horario():                                                            # --- Retorna o horário atual do sistema
            horario = datetime.now()                                   # horario recebe o horário atual
            horario = horario.strftime('%H:%M %Y %S')    # especifica o formato a ser recebido
            return horario                                                      #  retorna a varivel com o formato especificado                          

        # ************************************************
        # ************************************************
        
        def calcAlea (fim=1000):                     #  --- Retorna um número aleatório
            aleatorio = random.randint(0,fim)  # gerará um número aleatório, com o limite de 1000
            return aleatorio

        def calcPrimo (num):                        # -- -- Retorna um número primo    
            acumulador = 0                             # contador, armazena a quantidade de vezes, que um número é divisivel
            for n in range(1,num+1,1):          # loop, percorre de 1 até num + 1, ex.: num = 30, percorrerá de 1 até 31(30)
                aux = (num % n)                        # armazena divisão inteira, feita de num por todos os números de 1 até num
                if aux == 0:                                 # caso a divisão seja um valor inteiro, o contador é acrescentado em um
                    acumulador += 1
                if (aux ==0) and (n != 1) and (n !=num): # definição para um número não primo
                    return calcPrimo(num+1)    # retorna recursivamente para a função, sendo que retorna num + 1
            if acumulador <= 2:                       # caso o número seja dividido por apenas dois números
                return num                                 # retorna num
        
        numP = calcPrimo(calcAlea())     # numP recebe um número aleatório primo
        numQ = calcPrimo(calcAlea())    # numP recebe um número aleatório primo

        feedN = ((numP-1) * (numQ-1))     # feedN recebe a operação para calcular o 'fi' de N            

        minha_chaveE = calcPrimo(calcAlea(feedN-200)) # número primo, menor que feedN, para não ter erro, parâmetro feedN - 200
        minha_chaveN = (numP * numQ)

        minha_chaveD = 0                              # --- Calculo chaveD 
        x=0                                                        # contador x           
        while x < minha_chaveN:                   # repetirá até encontrar um valor, menor que N, que satisfaça a seguinte fórmula :
            r = (x * minha_chaveE) % feedN  # r = auxiliar, logo, se r = ('x' x minha_chaveE) % feedN == 1
            if r == 1:                          
                minha_chaveD = x                      # se r == 1, o laço para, e x passa a ser minha_chaveD
                break
            x += 1

        print('P {} * Q {} * N {} * D {} * E {}'.format(numP, numQ, minha_chaveN, minha_chaveD, minha_chaveE))
        # ************************************************
        
        def enviarChaves(delay):            
            try:
                
               nome = self.ed2.get()
               
               ip = '192.168.15.9'                                                                         # identifica o ip, que ira ser mandado os dados
               port = 2121                                                                                    # identifica a porta que será utilizada para envio/recebimento
               add = (ip, port)   
               clientSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)         # criação do objeto socket
               time.sleep(delay)                                                                           # tempo de atraso, para o envio assíncrono
               clientSocket.connect(add)                                                          # fazendo a conexão com o outro usuário  
               y = '#1-' + str(minha_chaveE) + "=" + str(minha_chaveN) + '+' + nome + '*'      # concatenando os dados a serem enviados
               
               clientSocket.sendto(y.encode(), (ip, port))                              # mandando os dados codificados em bytes
               clientSocket.close()                                                                 
               
            except ConnectionRefusedError:                                                 # tratamento de erro
               print('ConnectionRefusedError : Não foi possivel enviar as chaves')
        

        # ************************************************
        # ************************************************
        def recebeMensagem ():
            host = '192.168.15.8'                                                    # ip, a receber os dados
            port = 2121                                                                    # porta ser utilizada 
            add = (host, port)                                                         # tupla, contendo o ip e a porta      
            serv_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
            serv_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            serv_socket.bind(add)
            serv_socket.listen(10)
            enviarChaves(5)                                                             # inicia a função enviar chaves, que envia chaves e nome
            while True:                                                                        # mantém, sempre executando
                 global outro_chaveE, outro_chaveN                      # definindo variaveis globais, para se utilizar em outro trecho
                 con, cliente = serv_socket.accept()                      # aceitando conexão
                 recebe = con.recv(2024)
                 recebe = recebe.decode()                                       # decodificando de bytes para caracteres               
                 
                 if (recebe[0] == '#') and (recebe[1] == '1') and (recebe[2] == '-'):  # Verificando se a mensagem esta marcada                     
                     sliceKeyE = recebe.index('=')                                    # cortando a mensagem marcada - outro_chaveE
                     outro_chaveE = recebe[3:sliceKeyE]                      # definindo oque será utilizada - outro_chaveE
                      
                     sliceKeyN = recebe.index('+')                                    # cortando a mensagem marcada - outro_chaveN
                     outro_chaveN = recebe[sliceKeyE+1:sliceKeyN]  # definindo oque será utilizada - outro_chaveN

                     sliceName = recebe.index('*')                                    # cortando a mensagem marcada - nomeOutro
                     nomeOutro = recebe[sliceKeyN+1:sliceName]      # definindo oque será utilizada - nomeOutro
                     print('Nome : ', nomeOutro)

                     self.lbNomeOutro["text"] = nomeOutro                    # colocando o nome recebido no topo da janela
                     
                 else :
                     recebe = recebe.split('_')                                            # split, na mensagem recebida

                     recebeInt = []                                                                 # listas que armazenam os dados codificados
                     codificadoRsaRecebimento = []
                     preCodificadoRecebimento = []

                     for i in  recebe:                                                               # transformando os caracteres recebidos em string para inteiro
                         aux0 = int(i)
                         recebeInt.append(aux0)                                                
                      
                    # -- Decodificacao
                     for i in recebeInt:                                                            #  utilizando a minha_chaveD, para decodificar a mensagem
                         aux1 = (i ** minha_chaveD) % minha_chaveN
                         codificadoRsaRecebimento.append(aux1)
                         print(codificadoRsaRecebimento)  #
                         
                    # -- des pré Codificação
                     for i in codificadoRsaRecebimento:                           # decodificando os pré codificados
                         aux2 = alfabeto[i // 10]
                         preCodificadoRecebimento.append(aux2)
                         print(preCodificadoRecebimento)   #

                    # -- Reajuntando a mensagem                                             
                     mensagemOriginal = ''.join(preCodificadoRecebimento)
                     print('Mensagem Original : ', mensagemOriginal.capitalize())   #'''

                     # -- Mostrando na tela, no frame "frame"
                     labelMessage2 = Label(self.frame, text=mensagemOriginal.capitalize(), anchor=W, wraplength=200, bg="#faa6f4", width=63)
                     labelMessage2.pack(fill="both", padx=5, pady=10, ipadx=5, ipady=10)   



        # ************************************************
        def avancar(event):            
            time.sleep(5)                                                                                    # segurar o andamento em 5 segundos
           
            self.frameUm_nome["bg"] = "yellow"                              
            self.frameUm_nome.pack_forget()                                             # esquecer frame
            
            self.frameNome = Frame(master)                                               # frame 'frameNome', topo da tela para exibir nome do outro usuario
            self.frameNome.pack(side=TOP, fill="both")
            
            self.lbNomeOutro = Label(self.frameNome, text="Nome Outro", bg="#ff71ff") # label para exibir o nome no 'frameNome'
            self.lbNomeOutro.pack(fill=X, pady=5)

            self.frameShowMessage = Frame(master, bg="#ff71ff", relief=FLAT)# frame 'frameShowMessage', conterá as mensagens na tela
            self.frameShowMessage.pack(side=TOP, fill="both")

           # ************************************************
            def enviarMensagens(event):                              # função chamada por evento  "<Return>", enter pressionado
                global outro_chaveE, outro_chaveN                # indicando qua as variaveis setadas são globais

                # Mensagem      
                x = self.message.get().lower()                          # pegando e armazenando a mensagem 
                print(x)       

                # Mostrando na tela   
                labelMessage = Label(self.frame, text=x, anchor=E, wraplength=200, bg="#fdc5f8", width=63)
                labelMessage.pack(fill="both", padx=5, pady=10, ipadx=10, ipady=10)
                try:                                                                            # tentativa, caso não funcione, except executado        
                    print('Enviando')                   
                    ip = '192.168.15.9'
                    port = 2121
                    add = (ip, port)           
                    clientSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    clientSocket.connect(add)

                    # Chaves
                    outro_chaveE = int(outro_chaveE)                #  transformando as variaveis recebidas anteriormente em inteiros
                    outro_chaveN = int(outro_chaveN)                   
      
                     # Pré Cifragem   
                    preCodificadoEnvio = []                                    # listas que armazenam os dados codificados
                    codificadoRsaEnvio = []
                    codificadoRsaStringEnvio = []
           
                    for i in x:                                                                # armazenando os itens pre codificados  
                       aux3 = alfabeto.index(i) * 10
                       preCodificadoEnvio.append(aux3)

                    # Cifragem
                    for i in preCodificadoEnvio:                               # armazenando os itens codificados
                       aux4 = (i ** outro_chaveE) % outro_chaveN
                       codificadoRsaEnvio.append(aux4)

                    for i in codificadoRsaEnvio:                               # transformando os itens em strings para envio
                       aux5 = str(i)
                       codificadoRsaStringEnvio.append(aux5)
          
                    codificadoRsaEnvio = '_'.join(codificadoRsaStringEnvio)              # juntando os itens da lista em uma string
                   
                    clientSocket.sendto(codificadoRsaEnvio.encode(), (ip, port))    #  enviando a sting             
                    self.message.delete(0, END)                                                              # resentando o campo 'Entry' após envio
                    
                except ConnectionRefusedError:
                    print("Não foi possivel enviar sua mensagem")                               # tratamento de excessões

                self.message.delete(0, END)
      
           # ************************************************            
            def myfunction(event):
                canvas.configure(scrollregion=canvas.bbox("all"),width=550,height=470, bg="#ffe2fc")  # evento que permite o rolamento do scrolllbar
                
           # ************************************************
           
            self.myframe=Frame(master,relief=FLAT, bg="#ffe2fc") # frame que será inserido o canvas
            self.myframe.pack()         
        
            canvas=Canvas(self.myframe,width=550,height=470, bg="#ffe2fc") # criação do canvas
            self.frame=Frame(canvas, bg="#ffe2fc") #frame pertencente ao canvas, dentro do canvas
            myscrollbar=Scrollbar(self.myframe,orient="vertical",command=canvas.yview, bg="#ff71ff") # criando uma scrollbar
            canvas.configure(yscrollcommand=myscrollbar.set) #setando o movimento da scrollbar

            myscrollbar.pack(side="right",fill="y") # posicionando o scrollbar
            canvas.pack(side="left")# posicionando o canvas
            canvas.create_window((0,0),window=self.frame,anchor=NW)# criando o canvas
            self.frame.bind("<Configure>",myfunction) # ligando o evento "<Configure>", através do bind, a função myfunction
    
            # Mensagem apresentada ao usuário, no topo da tela
            self.labelMessage = Label(self.frameShowMessage, text="Sessão de chat criptografado ponta a ponta", wraplength=250, bg="#ffe2fc")
            self.labelMessage.pack(fill=X, padx=5, pady=10, ipadx=5, ipady=10)

            # Frame que conté, o campo de inserção das mensagens
            self.frameShowInput = Frame(master, bg="#ff71ff")                        
            self.frameShowInput.pack(side=BOTTOM, fill="both")

            # Campo de inserção da mensagem, 'Entry', dizendo a qual função será chamada, e qual evento
            self.message = Entry(self.frameShowInput, borderwidth=0, insertbackground="lightgray", bg="#ffe2fc")
            self.message.focus_set() # indicando foco automático
            self.message.bind("<Return>", enviarMensagens) # evento, função
            self.message.pack(fill=X, padx=20, pady=10) # posicionando o campo

            # criando um Thread para executar a função receber, de forma paralela a execução do programa
            funcao1 = Thread (target=recebeMensagem) 
            funcao1.start() # iniciando a execução do Thread
            
        # ************************************************
        # Nome
        self.frameUm_nome = Frame(master, bg="#ff71ff")                      # Frame M                                                                                                              
        self.frameUm_nome.pack(fill="both", pady=250)

        # Label + Entry
        self.lb1 = Label(self.frameUm_nome, text = "Open : "+ horario() + ' s', anchor=W, fg="#fff", bg="#ff71ff").pack(fill=X)
        self.lb2 = Label(self.frameUm_nome, text = "Nome : ", anchor=W, fg="#fff", bg="#ff71ff").pack(fill=X, padx=150)
        
        self.ed2 = Entry(self.frameUm_nome, width=30, borderwidth=0, insertbackground="lightgray", bg="#ff71ff", fg="#fff")
        self.ed2.focus_set()
        self.ed2.bind("<Return>", avancar)
        self.ed2.pack(pady=5)

root = Tk()
root.geometry("550x620+250+80")
root.configure(background="#ffe2fc")
Aplicacao(root)
root.mainloop()  
